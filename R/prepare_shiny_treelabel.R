
dummy_precalc_result <- list(
  col_data = \() NULL,
  dim_reductions = \(name) NULL,
  counts = \(gene, cell) NULL,
  da_results = \(treelabel, top_selection, targets) NULL,
  da_meta_results = \(treelabel, top_selection, targets) NULL
)

#' Wrapper for shinyApp
#'
#' @param spec object generated by `init_shinyTreelabel` that describes the content that will be displayed
#' @param sce a `SingleCellExperiment`. It is used to calculate the differential expression results. If
#'   `precalc_results` is provided and it is complete (containing DA and DE results), `sce` is not needed.
#' @param col_data a `data.frame`. It is used to calculate the differential abundance results. If
#'   `precalc_results` is provided and it is complete (containing DA and DE results), `col_data` is not needed.
#' @param precalc_results the output from `precalculate_results` to avoid calculating expensive
#'   results on the fly.
#' @param ... the parameters forwarded to `shiny::shinyApp`
#'
#' @returns Does not return anything, but blocks the thread and serves HTTP responses.
#'
#' @export
make_treelabel_app <- function(spec, sce = NULL, col_data = NULL, precalc_results = NULL, ...){
  stopifnot(! is.null(sce) || ! is.null(col_data) || ! is.null(precalc_results))

  # Nice styling
  theme_set(cowplot::theme_cowplot())

  if(is.null(precalc_results)){
    precalc_results <- dummy_precalc_result
  }else if(is.character(precalc_results)){
    precalc_results <- PrecalculatedResults$new(dbfile = precalc_results)
  }
  stopifnot(inherits(precalc_results, "PrecalculatedResults"))

  obj <- list(
    col_data = \(){
      cd <- col_data %||% precalc_results$col_data() %||% colData(sce)
      as_tibble(cd)
    },
    dim_reductions = \(name){
        precalc_results$dim_reductions(name) %||% reducedDim(sce, name)
    },
    counts = \(gene, cell){
      precalc_results$counts(gene, cell) %||% ({
        mat <- assay(sce, spec$count_assay_name)
        if(missing(gene) && missing(cell)) mat
        else if(missing(gene)) mat[,cell,drop=FALSE]
        else if(missing(cell)) mat[gene,,drop=FALSE]
        else mat[gene,cell,drop=FALSE]
      })
    },
    da_results = \(treelabel, top_selection, targets){
      precalc_results$da_results(treelabel, top_selection, targets) %||%
        get_differential_abundance_results(obj, spec, treelabel, top_selection, targets)
    },
    da_meta_results = \(treelabel, top_selection, targets){
      precalc_results$da_meta_results(treelabel, top_selection, targets) %||%
        calculate_meta_differential_abundance_results(obj$da_results(treelabel, top_selection, targets))
    },
    de_results = \(treelabel, celltype, gene){
      precalc_results$de_results(treelabel, celltype, gene) %||%
        get_differential_expression_results(obj, spec, treelabel, celltype, gene)
    },
    de_meta_results = \(treelabel, celltype, gene){
      precalc_results$de_meta_results(treelabel, celltype, gene) %||%
        calculate_meta_differential_expression_results(
          obj$de_results(treelabel, celltype, gene)
        )
    }
  )

  shiny::shinyApp(singlecell_treelabel_ui(spec), singlecell_treelabel_server2_gen(spec, obj), ...)
}


#' Prepare App
#'
#' @export
init_shinyTreelabel <- function(sce, treelabels = where(is_treelabel),
                                design = ~ 1,
                                pseudobulk_by = NULL,
                                metaanalysis_over = NULL,
                                gene_expr_by = NULL,
                                contrasts = vars(Intercept = cond()),
                                de_test = c("limma", "glmGamPoi"),
                                dim_reductions = NULL,
                                count_assay = "counts",
                                treelabel_threshold = 0.5){

  if(! is(sce, "SummarizedExperiment")){
    stop("Cannot handle 'sce' of class ", toString(class(sce), width = 60))
  }

  col_data <- as_tibble(SummarizedExperiment::colData(sce))
  de_test <- rlang::arg_match(de_test)
  if(is.null(dim_reductions)){
    dim_reductions <- SingleCellExperiment::reducedDimNames(sce)
  }
  contrasts <- rlang::quos_auto_name(contrasts)
  design_variables <- if(rlang::is_function(design)){
    lemur:::design_variable_to_quosures(design(col_data), data = col_data)
  }else{
    lemur:::design_variable_to_quosures(design, data = col_data)
  }

  col_data <- col_data |>
    mutate(across({{treelabels}}, \(x) tl_modify(x, .scores >= treelabel_threshold)))
  vec <- vctrs::vec_ptype_common(!!! dplyr::select(col_data, where(is_treelabel)))
  treelabel_names <- names(tidyselect::eval_select({{treelabels}}, data = col_data))
  metaanalysis_levels <- if(is.null(metaanalysis_over)){
    NULL
  }else{
    tmp <- lapply(metaanalysis_over, \(mo){
      if(is.factor(col_data[[mo]])){
        levels(col_data[[mo]])
      }else{
        unique(as.character(col_data[[mo]]))
      }
    })
    names(tmp) <- metaanalysis_over
    tmp
  }

  list(
    treelabel_names = treelabel_names,
    tree = tl_tree(vec),
    root = tl_tree_root(vec),
    metaanalysis_over = metaanalysis_over,
    metaanalysis_levels = metaanalysis_levels,
    gene_expr_by = gene_expr_by,
    pseudobulk_by = c(pseudobulk_by, design_variables),
    design = design,
    contrasts = contrasts,
    de_test = de_test,
    count_assay_name = count_assay,
    dim_reduction_names = dim_reductions %||% character(0L),
    gene_names = rownames(sce) %||% as.character(seq_len(1:nrow(sce)))
  )
}





check_init <- function(){
  stopifnot(all(c("col_data","treelabel_names", "tree", "root",  "dim_reductions",  "counts", "metaanalysis_over",
                  "gene_expr_by", "pseudobulk_by", "design", "contrasts", "de_test", "precalc_res") %in% names(.vals)))
}




#' Speed-up app by precalculating the results
#'
#' @param spec the specification which results to precalculat generated by `init_shinyTreelabel`.
#' @param sce the `SingleCellExperiment` object that is used to calculate the differential abundance
#'   and differential expression results.
#' @param output specify which set of results are calculate. By default differential abundance, differential
#'   expression, and the meta analysis of the differential expression are calculated.
#' @param treelabel_sel calcualte the results only for a subset of the treelabel columns. Default: use all
#'   from `spec$treelabel_names`.
#' @param dbfile the location where the precalculated results are stored. Default: `":memory:"` (i.e.,
#'   in memory).
#' @param verbose should a progress bar be printed.
#'
#' @returns an object of the R6 class `PrecalculatedResults`.
#'
#' @export
precalculate_results <- function(spec, sce, output = c("da", "de", "de_meta"),
                                 treelabel_sel = NULL, dbfile = ":memory:", clear_file = TRUE,
                                 verbose = TRUE){
  storage <- PrecalculatedResults$new(dbfile)
  if(clear_file){
    storage$clear()
  }

  col_data <- as_tibble(colData(sce))
  if(! clear_file) storage$clear_col_data()
  storage$add_col_data(col_data)

  if(is.null(treelabel_sel)){
    treelabel_sel <- spec$treelabel_names
  }else{
    stopifnot(all(treelabel_sel %in% spec$treelabel_names))
  }
  nodes <- igraph::V(spec$tree)$name
  aggr_by <- dplyr::transmute(col_data, !!! spec$pseudobulk_by)
  col_data_cp <- col_data
  for(new_name in colnames(aggr_by)){
    col_data_cp[[new_name]] <- aggr_by[[new_name]]
  }

  if(TRUE){ # Always store the dim_reductions
    if(! clear_file) storage$clear_reducedDimensions()
    all_redDims <- reducedDims(sce)[spec$dim_reduction_names] |>
      lapply(\(x) if(ncol(x) == 0){
        matrix(0, nrow = length(spec$gene_names), ncol = 2)
      }else if(ncol(x) == 1){
        cbind(x, 0)
      }else{
        x[,1:2,drop=FALSE]
      }) |>
      enframe(name = "name", value = "embedding")
    storage$add_reducedDimensions_rows(all_redDims)
  }

  if("da" %in% output){
    if(! clear_file) storage$clear_da()
    if(! clear_file) storage$clear_da_meta()
    for(ts in treelabel_sel){
      i <- 1; total_steps <- length(nodes)
      n <- spec$root;
      if(verbose){
        cli::cli_progress_step("DA Step {i}/{total_steps} | ETA: {cli::pb_eta}: '{ts}' calculating '{n}'",
                               msg_done = paste0(" Finished '", ts, "' DA analysis"), total = total_steps)
      }
      for(n in nodes){
        full_da <- calculate_differential_abundance_results(spec, col_data_cp,  treelabel = ts, node = n,
                                                        aggregate_by = all_of(colnames(aggr_by)))
        storage$add_da_rows(full_da)
        i <- i+1
        if(verbose) tryCatch(cli::cli_progress_update(force = TRUE, inc = 1), error = \(err){})
      }
    }
    if(verbose) cli::cli_process_done()
    meta <- tbl(storage$con, "da") |>
      dplyr::collect() |>
      calculate_meta_differential_abundance_results()
    storage$add_da_meta_rows(meta)
  }

  if("de" %in% output){
    if(! clear_file) storage$clear_de()
    counts <- assay(sce, spec$count_assay_name)
    for(ts in treelabel_sel){
      i <- 1; total_steps <- length(nodes)
      n <- spec$root
      if(verbose){
        cli::cli_progress_step("DE Step {i}/{total_steps} | ETA: {cli::pb_eta}: '{ts}' calculating '{n}'",
                               msg_done = paste0(" Finished '", ts, "' DE analysis"), total = total_steps)
      }
      for(n in nodes){
        full_de <- calculate_differential_expression_results(spec, col_data_cp, counts = counts, treelabel = ts,
                                               celltype = n, aggregate_by = vars(!!! rlang::syms(colnames(aggr_by))))
        storage$add_de_rows(full_de)
        i <- i+1
        if(verbose) tryCatch(cli::cli_progress_update(force = TRUE, inc = 1), error = \(err){})
      }
    }
  }
  if("de_meta" %in% output && DBI::dbExistsTable(storage$con, "de")){
    if(! clear_file) storage$clear_de_meta()
    if(verbose) tryCatch(cli::cli_status("DE meta-analysis"))
    full_data <- tbl(storage$con, "de") |>
      dplyr::collect()
    if(! is.null(full_data) && nrow(full_data) > 0){
      meta <- calculate_meta_differential_expression_results(full_data)
      storage$add_de_meta_rows(meta)
    }
    if(verbose) tryCatch(cli::cli_status_clear(result = "done", msg_done = paste0("Finished DE meta analysis")))
  }

  storage
}


